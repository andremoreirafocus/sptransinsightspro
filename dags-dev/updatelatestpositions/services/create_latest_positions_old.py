import logging
from updatelatestpositions.infra.db import get_db_connection
from psycopg2 import DatabaseError, InterfaceError

logger = logging.getLogger(__name__)


def create_latest_positions_table(config):
    """
    Creates and heals the trusted.trip_details table.
    Ensures return trips (-1) are generated by mirroring forward trips (-0)
    if the return data is missing from the source.
    """
    lastest_positions_table_name = config["LATEST_POSITIONS_TABLE_NAME"]
    positions_table_name = config["POSITIONS_TABLE_NAME"]
    conn = None
    # We use a CTE to define the base math, then a UNION to patch the missing trips
    sql_command = f"""
        DROP TABLE IF EXISTS {lastest_positions_table_name};
        CREATE TABLE {lastest_positions_table_name} AS
        WITH latest_snapshot AS (
            -- 1. Captura o timestamp exato do último lote de extração
            SELECT MAX(extracao_ts) AS max_ts
            FROM trusted.positions
        )
        -- 2. Projeta os dados e calcula o trip_id com o mapeamento 1->0 e 2->1
        SELECT 
            p.veiculo_ts,
            p.veiculo_id, 
            p.veiculo_lat,  
            p.veiculo_long, 
            p.linha_lt, 
            p.linha_sentido,
            -- Concatenação da linha com o sentido mapeado
            p.linha_lt || '-' || (
                CASE 
                    WHEN p.linha_sentido = 1 THEN '0' 
                    WHEN p.linha_sentido = 2 THEN '1' 
                    ELSE NULL -- Garante integridade para valores inesperados
                END
            ) AS trip_id
        FROM {positions_table_name} p
        JOIN latest_snapshot ls ON p.extracao_ts = ls.max_ts;
    """
    try:
        conn = get_db_connection(config)
        cur = conn.cursor()
        cur.execute(sql_command)
        conn.commit()
        logger.info("Successfully created latest positions table.")
    except (DatabaseError, InterfaceError) as db_err:
        if conn:
            conn.rollback()
        logger.error(f"Database error during table creation: {db_err}")
        raise
    finally:
        if conn:
            cur.close()
            conn.close()
